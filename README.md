# remap_plugin_base

> ⚠️ *This README was automatically generated by a LLM and should be manually reviewed for accuracy* ⚠️

`remap_plugin_base` provides a base class for developing ReMap plugins. It offers core functionality for setting up nodes, managing clients, and interacting with a fact-based knowledge base.

## Features

- Base class for ReMap plugin development
- Manages ROS 2 node setup
- Handles region registration and removal
- Publishes and removes facts from the knowledge base
- Supports semantic mapping and simulation control

## Installation

Clone the repository and build it using `colcon`:

```sh
cd <your_ros2_workspace>/src
git clone <repository_url>
cd ..
colcon build --packages-select remap_plugin_base
```

## Usage

To use `remap_plugin_base`, inherit from `remap::plugins::PluginBase` in your custom plugin.

### Example

```cpp
#include <remap_plugin_base/plugin_base.hpp>

class MyPlugin : public remap::plugins::PluginBase {
public:
  MyPlugin() {}
  void customFunction() {
    pushFact("example_fact");
  }
};
```

## API Reference

### PluginBase Class

#### Constructor

```cpp
PluginBase();
PluginBase(std::shared_ptr<regions_register::RegionsRegister> & regions_register);
```

Initializes the base class, optionally accepting a `RegionsRegister` instance.

#### Setup Function

```cpp
void setup(
  const std::shared_ptr<rclcpp::Node> & node_ptr,
  const std::string & name,
  const bool & threaded);
```

Sets up the plugin node, clients, and knowledge base publishers.

#### Fact Management

```cpp
void pushFact(const std::string & fact) const;
void removeFact(const std::string & fact) const;
```

Publishes or removes a fact from the knowledge base.

### SemanticPlugin Class

`SemanticPlugin` extends `PluginBase`, providing additional functionalities for semantic mapping and simulation control.

#### Constructor

```cpp
SemanticPlugin();
SemanticPlugin(
  std::shared_ptr<map_handler::SemanticMapHandler> & semantic_map,
  std::shared_ptr<remap::regions_register::RegionsRegister> & regions_register);
```

#### Simulation Control

```cpp
void initializeSimulationStructures();
```

Initializes ROS 2 subscriptions for simulation control.

#### Simulation Callbacks

```cpp
void startSimulationCallback(const std_msgs::msg::Bool::SharedPtr msg);
void stopSimulationCallback(const std_msgs::msg::Bool::SharedPtr msg);
void stepCallback(const std_msgs::msg::Float32::SharedPtr msg);
void forwardCallback(const std_msgs::msg::Bool::SharedPtr msg);
void backwardCallback(const std_msgs::msg::Bool::SharedPtr msg);
```

Handles simulation start, stop, stepping, and directional control.

#### Setters

```cpp
void setSemanticMapHandler(
  std::shared_ptr<map_handler::SemanticMapHandler> & semantic_map);
void setRegionsRegister(
  std::shared_ptr<remap::regions_register::RegionsRegister> & regions_register);
```

Allows setting the semantic map handler and regions register dynamically.

#### Storing spatial relationships

Each plugin can store spatial relationships in the knowledge base, starting
from the generic spatial relationships computed by the `map_handler::SemanticMapHandler`
or the information it can extract from the `regions_register::RegionsRegister`.

To do this, each plugin should implement the following functions:

```cpp
virtual void storeRegionsRelationships(
    std::map<int, std::map<int,
    std::string>> relationships_matrix);
virtual void storeEntitiesRelationships(
    std::map<std::string, std::map<std::string,
    std::string>> relationships_matrix);
```

These functions are called by the `remap_manager` for each plugin
after every plugin has contributed and stored its information both
in the knowledge base and in the 3D grid. The `map_handler::SemanticMapHandler`
object can compute the generic spatial relationships both for regions and entities.
The plugins can decide which of these relationships they want to use to compute the
domain specific spatial relationships and push them to the knowledge base.

Both funtions receive a matrix of relationships:
- `std::map<int, std::map<int, std::string>> relationships_matrix` is the
  matrix of relationships between the reMap regions, identified by their numeric
  IDs. To be able to compute inter-entities relationships, you should extract 
  information about the entities contained in each region. This is possible via
  the `regions_register::RegionsRegister` API.
- `std::map<std::string, std::map<std::string, std::string>> relationships_matrix`
  is the matrix of relationships between the entities, identified by their names.
  Ideally (that is, if all the plugins are doing their job correctly) these names
  should be the same as the one used to identify the entities in the knowledge base.

## License

This project is licensed under the Apache License 2.0. See LICENSE for details.

## Author

PAL Robotics, S.L.

## Contributions

Contributions are welcome! Feel free to open an issue or submit a pull request.

